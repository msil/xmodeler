<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Pattern Matching</title><link rel="stylesheet" href="book.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="XMF Bluebook"><link rel="up" href="ch21.html" title="XOCL"><link rel="prev" href="ch21s07.html" title="Assignment"><link rel="next" href="ch21s09.html" title="Data Type Operations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id586945"></a>Pattern Matching</h2></div></div></div><p>XOCL provides a powerful pattern matching language. This greatly
    simplifies the writing of pattern matching operations that would otherwise
    require a very imperative style of programming.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id587076"></a>Patterns and Pattern Matching</h3></div></div></div><p>A pattern is matched against a value. The pattern match may
      succeed or fail in a given matching context. A matching context keeps
      track of any variable bindings generated by the match and maintains
      choice points for backtracking if the current match fails.</p><p>Pattern matching can be viewed as being performed by a pattern
      matching engine that maintains the current pattern matching context as
      its state. The engine state consists of a stack of patterns to be
      matched against a stack of values, a collection of variable bindings and
      a stack of choice points. A choice point is a machine state. At any
      given time there is a pattern at the head of the pattern stack and a
      value at the head of the value stack. The machine executes by performing
      state transitions driven by the head of the pattern stack: if the outer
      structure of the pattern matches that of the value at the head of the
      value stack then:</p><div class="itemizedlist"><ul type="disc"><li><p>0 or more values are bound.</p></li><li><p>0 or more choice points are added to the choice point
          stack.</p></li><li><p>0 or more component patterns are pushed onto the pattern
          stack.</p></li><li><p>0 or more component values are pushed onto the value
          stack.</p></li><li><p>If the machine fails to match the pattern and value at the
          head of the respective stacks then the most recently created choice
          point is popped and becomes the new machine state. Execution
          continues until either the pattern stack is exhausted or the machine
          fails when the choice stack is empty.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id648785"></a>Pattern Categories</h3></div></div></div><p>This section describes the different categories of pattern. The
      semantics of matching are defined informally in terms of a general
      description and example definitions involving the pattern.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id606370"></a>Variables</h4></div></div></div><p>A variable pattern consists of a name, optionally another
        pattern and optionally a type. The simplest form of variable pattern
        is just a name, for example, the formal parameter x is a variable
        pattern:</p><pre class="programlisting">let add1 = @Operation(x) x + 1 end in ...</pre><p>Matching
        a simple variable pattern such as that shown above always succeeds and
        causes the name to be bound to the corresponding value. A variable may
        be qualified with a type declaration:</p><pre class="programlisting">let add1 = @Operation(x:Integer) x + 1 end in ...</pre><p>which
        has no effect on pattern matching. A variable may be qualified with a
        pattern as in x = &lt;Pattern&gt; where the pattern must occur before
        any type declaration. Such a qualified variable matches a value when
        the pattern also matches the value. Any variables in the pattern and x
        are bound in the process.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id617583"></a>Constants</h4></div></div></div><p>A constant pattern is either a string, an integer, a boolean or
        an expression (in the case of an expression the pattern consists of [
        followed by an expression followed by ]). A constant pattern matches a
        value when the values is equal to the constant (in the case of an
        expression the matching process evaluates the expression each time the
        match occurs). For example:</p><pre class="programlisting">let fourArgs = @Operation(1,true,"three",x = [2 + 2]) x end in ...</pre><p>is
        an operation that succeeds in the case: </p><pre class="programlisting">fourArgs(1,true,"three",4)</pre><p>and
        returns 4.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id700749"></a>Sequences</h4></div></div></div><p>A sequence pattern consists of either a pair of patterns or a
        sequence of patterns. In the case of a pair:</p><pre class="programlisting">let head = @Operation(Seq{head | tail}) head end in ...</pre><p>the
        pattern matches a non-empty sequence whose head must match the head
        pattern and whose tail must match the tail pattern. In the case of a
        sequence of patterns:</p><pre class="programlisting">let add3 = @Operation(Seq{x,y,z}) x + y + z end in ...</pre><p>the
        pattern matches a sequence of exactly the same size where each element
        matches the corresponding pattern.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id628698"></a>Constructors</h4></div></div></div><p>A constructor pattern matches an object. A constructor pattern
        may be either a by-order-of-arguments constructor pattern (or
        BOA-constructor pattern) or a keyword constructor pattern. A
        BOA-constructor pattern is linked with the constructors of a class. It
        has the form:</p><pre class="programlisting">let flatten = @Operation(C(x,y,z)) Seq{x,y,z} end in ...</pre><p>where
        the class {\tt C} must define a 3-argument constructor. A
        BOA-constructor pattern matches an object when the object is an
        instance of the class (here {\tt C} but in general defined using a
        path) and when the object's slot values identified by the constructor
        of the class with the appropriate arity match the corresponding
        sub-patterns (here xy and z). A keyword constructor pattern has the
        form:</p><pre class="programlisting">let flatten = @Operation(C[name=y,age=x,address=y]) Seq{x,y,z} end in ...</pre><p>where
        the names of the slots are explicitly defined in any order (and may be
        repeated) .Such a pattern matches an object when it is an instance of
        the given class and when the values of the named slots match the
        appropriate sub-patterns.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id655469"></a>Conditions</h4></div></div></div><p>A conditional pattern consists of a pattern and a predicate
        expression. It matches a value when the value matches the sub-pattern
        and when the expression evaluates to true in the resulting variable
        context. For example:</p><pre class="programlisting">let repeat = @Operation(Seq{x,y} when x = y) Seq{x} end in ...</pre><p>Note
        that the above example will fail (and probably throw an error
        depending on the context) if it is supplied with a pair whose values
        are different.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id590452"></a>Sets</h4></div></div></div><p>Set patterns consist of an element pattern and a residual
        pattern. A set matches a pattern when an element can be chosen that
        matches the element pattern and where the rest of the set matches the
        residual pattern. For example:</p><pre class="programlisting">let choose = @Operation(S-&gt;including(x)) x end in ...</pre><p>which
        matches any non-empty set and selects a value from it at random. Set
        patterns introduce choice into the current context because often there
        is more than one way to choose a value from the set that matches the
        element pattern. For example:</p><pre class="programlisting">let chooseBigger = @Operation(S-&gt;including(x),y where x &gt; y) x end in ...</pre><p>Pattern
        matching in chooseBigger, for example:</p><pre class="programlisting">chooseBigger(Set{1,2,3},2)</pre><p>starts
        by selecting an element and binding it to x and binding S to the rest.
        In this case suppose that x = 1 and S = Set{2,3}. The pattern y
        matches and binds 2 and then the condition is applied. At this point,
        in general, there may be choices left in the context due to there
        being more than one element in the set supplied as the first
        parameter. If the condition x &gt; y fails then the matching process
        jumps to the most recent choice point (which in this cases causes the
        next element in the set to be chosen and bound to x). Suppose that 3
        is chosen this time; the condition is satisfied and the call returns3.
        The following is an example that sorts a set of integers into
        descending order:</p><pre class="programlisting">context Root
  @Operation sort(S)
    @Case S of
      Set{} do Seq{} end
      S-&gt;including(x) 
        when S-&gt;forAll(y | y &lt;= x) 
        do Seq{x | Q} where Q = sort(S) 
      end
    end
  end</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id601131"></a>Sequences</h4></div></div></div><p>Sequence patterns use the infix + operator to combine two
        patterns that match against two sub-sequences. For example the
        following operation removes a sequence of 0's occurring in a
        sequence:</p><pre class="programlisting">context Root
  @Operation remove0s(x) 
    @Case x of 
      (S1 when S1-&gt;forAll(x | x &lt;&gt; 0)) + 
        (S2 when S2-&gt;forAll(x | x = 0)) + 
        (S3 when S3-&gt;forAll(x | x &lt;&gt; 0)) 
      do S1 + S3 
      end 
    end
  end</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id639319"></a>Syntax</h4></div></div></div><p>Syntax patterns consist of expressions within quasi-quotes [|
        and |]. The quotes are a short-hand for writing out the equivalent
        constructor patterns. Syntax patterns provide a powerful way of
        constructing syntax mappings where the pattern is defined in terms of
        concrete syntax rather than the equivalent abstract syntax structures.
        Consider an operation that extracts the body of a
        letexpression:</p><pre class="programlisting">context Root
  @Operation getBody([| let x = value in body end |]) 
    body 
  end</pre><p>Unfortunately, this will not work as you may expect
        since the syntax pattern states that the operation expects to be
        supplied with a let expression that consists of exactly one binding
        and where the body of the expression is the variable whose name is
        body. We wish to place patterns within the syntax construct that match
        against specific elements of the abstract syntax structure. To do this
        we use pattern-unquotes:</p><pre class="programlisting">context Root
  @Operation getBody([| let &lt;| bindings |&gt; in &lt;| body |&gt; end |]) 
    body 
   end</pre><p>Within a syntax pattern the unquotes &lt;| and |&gt;
        are used to surround patterns that are to be matched against the
        abstract syntax structures occurring at that point in the supplied
        expression. In the example above, bindings is bound to the sequence of
        bindings in the let and body is bound to the body. The following
        example shows an operation that calculates the free variables
        occurring in an expression. The expression is limited to a small
        number of XOCL expressions: </p><pre class="programlisting">context Root
  @Operation FV(e)
    @Case e of 
      [| let &lt;| Seq{} |&gt; in &lt;| e |&gt; end |] do 
         FV(e) 
         end
      [| let &lt;| Seq{ ValueBinding(v,e1) | bs } |&gt;
         in &lt;| e2 |&gt; 
         end
      |] do
         FV([| let &lt;bs&gt; in &lt;e2&gt; end|])-&gt;excluding(v)
         end
      [| if &lt;| e1 |&gt; 
         then &lt;| e2 |&gt;
         else &lt;| e3 |&gt; 
         end 
      |] do
         FV(e1) + FV(e2) + FV(e3)
      end
      [| &lt;| e1 |&gt; = &lt;| e2 |&gt; |] do
         FV(e1) + FV(e2)
      end
      Var[name=n] do 
         Set{n} 
      end
    end
  end</pre><p>The following call:</p><pre class="programlisting">FV[| let x = 10; y = 20 in if x = y then z else a end end |])</pre><p>produces
        the set </p><pre class="programlisting">Set{a,z}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id563234"></a>Pattern Contexts</h3></div></div></div><p>Patterns may be used in the following contexts:</p><p>Operation Parameters. Each parameter in an operation definition is
      a pattern. Parameter patterns are useful when defining an operation that
      must deconstruct one or more values passed as arguments. Note that if
      the pattern match fails then the operation invocation will raise an
      error. Operations defined in the same class and with the same name are
      merged into a single operation in which each operation is tried in turn
      when the operation is called via an instance of the class. Therefore in
      the following example:</p><pre class="programlisting">@Class P
   @Operation f(Seq{}) 0 end
   @Operation f(Seq{x | t}) x + self.f(t) end
end</pre><p>an instance of P has a single operation f that adds up all
      the elements of a sequence.</p><p>Case Arms. A case expression consists of a number of arms each of
      which has a sequence of patterns and an expression. A case expression
      dispatches on a sequence of values and attempts to match them against
      the corresponding patterns in each arm in turn. For example, suppose we
      want to calculate the set of duplicated elements in a pair of
      sets:</p><pre class="programlisting">context Root
   @Operation dups(s1,s2)
     @Case s1,s2 of
         s1-&gt;including(x),s2-&gt;including(y) when x = y do 
            Set{x} + dups(s1,s2) 
         end
         s1-&gt;including(x),s2 do 
           dups(s1,s2) 
         end
         s1,s2-&gt;including(y) do 
            dups(s1,s2) 
         end
         Set{},Set{} do 
            Set{} 
         end
     end
   end</pre><p>In XMap transformations, as described in the XMap
      manual.</p></div></div><p></p><p><img src="copyright.gif"></p></body></html>
