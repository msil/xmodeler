<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Data Type Operations</title><link rel="stylesheet" href="book.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="XMF Bluebook"><link rel="up" href="ch21.html" title="XOCL"><link rel="prev" href="ch21s08.html" title="Pattern Matching"><link rel="next" href="ch21s10.html" title="Relationship to OCL and ASL"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id657006"></a>Data Type Operations</h2></div></div></div><p></p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id666708"></a>Boolean</h3></div></div></div><p>A value of the Boolean type can either be true or false.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id606923"></a>Operators</h4></div></div></div><p>All the usual Boolean operators are provided.</p><div class="table"><a name="id664366"></a><p class="title"><b>Table 1. </b></p><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>
                  <span class="emphasis"><em>Operators</em></span>
                </td><td>
                  <span class="emphasis"><em>Syntax</em></span>
                </td><td>
                  <span class="emphasis"><em>Result Type</em></span>
                </td></tr><tr><td>Or</td><td>a or b</td><td>Boolean</td></tr><tr><td>And</td><td>a and b</td><td>Boolean</td></tr><tr><td>negation</td><td>not b</td><td>Boolean</td></tr><tr><td>equals</td><td>a = b</td><td>Boolean</td></tr><tr><td>not equals</td><td>a &lt;&gt; b</td><td>Boolean</td></tr><tr><td>implies</td><td>a implies b</td><td>Boolean</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id707657"></a>Examples</h4></div></div></div><pre class="programlisting">not true
balance &gt; 0 or balance &lt; 100
x &lt;&gt; y implies x.name &lt;&gt; y.name</pre><p>The following
        example shows the definition of the logical operator and. It uses an
        if statement to test whether other is a Boolean value and if it is
        returns the conjunct of self and other. An error is reported if the
        type is incorrect.</p><pre class="programlisting">context Boolean
@Operation booland(other)
      if other.isKindOf(Boolean)
      then
        self and other
      else
        self.error("Boolean::booland expects a boolean " + other.toString())
      end
    end</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id587058"></a>Channels</h3></div></div></div><p>XOCL provides channels to perform input and output. The channel
      classes are defined in the IO package and are defined in a separate
      document. This section provides a very brief overview of input and
      output using channels.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id599417"></a>Standard Input and Output</h4></div></div></div><p>XOCL provides two channels as global variables defined in the
        name space Root. The output channel stdout is used to send characters
        to the standard output. The input channel stdin reads characters from
        the standard input. In both cases characters are represented as
        integer character codes in the range 0 to 255. Characters are written
        on output channels by outch.write(c) and read from input channels by
        inch.read().</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id630036"></a>Formatting Output</h4></div></div></div><p>XOCL provides a convenient means for formatting output to
        channels. The global variable format is bound to a character formatter
        that is used as an operation by applying it to arguments that control
        the output of characters. The general form is:</p><pre class="programlisting">format(outch,formatString,args)</pre><p>where
        the format string is a string of characters controlling how the
        sequence of argument values is formatted as output to the output
        channel. A format string is a sequence of characters and format
        directives. Each character occurring in a format string is written to
        the output channel in sequence. A format directive starts with the
        tilde (~) character and controls how the output is written and how the
        fomat arguments are consumed and written to the output channel. A
        typical use of format will print a message followed by a newline. A
        newline is produced using the format directive ~% as
        in:</p><pre class="programlisting">format(outch,&#8221;hello world~%&#8221;,Seq{})</pre><p>Note
        that there are no format arguments in the example above. Where there
        are no format args, they can be omitted: </p><pre class="programlisting">format(outch,&#8221;hello world~%&#8221;)</pre><p>The
        directive ~S consumes the next format argument, translates it to a
        string and prints it to the output channel. For example, if we want to
        print out the source and target of an edge with an arrow between them:
        </p><pre class="programlisting">format(outch,&#8221;~S -&gt; ~S~%&#8221;,Seq{edge.source,edge.target})</pre><p>Format
        defines many other directives that are defined in the XMF guide to
        IO.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id609269"></a>File Based Input and Output</h4></div></div></div><p>The IO package of XMF provides file channels for accessing and
        updating files. These channels are defined in the XMF guide to IO. A
        useful special form is provided that hides the details of file
        IO:</p><pre class="programlisting">@WithOpenFile(inch &lt;- filename)
  // Use inch.read() to read characters from the file.
  // inch.read() returns -1 when EOF is reached.
end</pre><pre class="programlisting">@WithOpenFile(outch -&gt; filename)
  // Use outch in format expressions to write characters to the file.
end</pre><p>In both of the examples above the filename is specified as
        an expression whose value is a string. The channels used to perform
        the input and output are automatically closed when the WithOpenFile
        expression completes. If an IO error occurs during the evaluation of
        the WithOpenFile then XOCL guarantees that the channels are closed
        before the error is reported.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id660359"></a>Clients</h3></div></div></div><p>XOCL provides clients that can be used to connect to external
      servers on ports and then communicate via input output channels with the
      server.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id660931"></a>Daemons</h3></div></div></div><p>An XOCL daemon is an operation that is attached to an object&#8217;s
      slot such that whenever the slot changes state the operation is invoked.
      The invocation is referred to as firing the daemon. There are several
      different types of daemon depending on the required firing mode: whether
      the operation is invoked when any change occurs, when a new value is
      added to the slot or when a value is removed from the slot.</p><p>A new daemon is created using the Daemon
      constructor:</p><pre class="programlisting">Daemon(id,type,slot,action,persistent,traced,target)</pre><p>Where
      id is any XOCL value and is used to identify the daemon in a given
      context; type is an integer determining the firing mode of the daemon;
      slot is a symbol that names the slot that is being monitored by the
      daemon (or null if this is not appropriate); action is an operation to
      be invoked when the daemon fires; persistent is a boolean value
      determining whether or not the daemon will be saved when an object
      containing the daemon is saved to a XAR file; traced is a boolean value
      that determines whether or not tracing information is printed when the
      daemon fires; target is any XOCL value and provides a means of
      associating state with a daemon.</p><p>The type of the daemon is supplied as an integer value. The types
      are defined by an enumerated type defined in the class Daemon; the type
      determines the number of arguments that the action should have. The
      following table lists the types and provides skeleton operations of the
      appropriate form for the daemon type:</p><div class="table"><a name="id493942"></a><p class="title"><b>Table 2. </b></p><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>Type</td><td>Description</td><td>Action Skeleton</td></tr><tr><td>XCore::Daemon::ANY</td><td>Any change to the object will fire the daemon. The action is supplied with the object, the name of the slot that changes, the new value and the old value of the slot. The value of slot in the construction of the daemon is null.</td><td>@Operation(object,slot,newValue,oldValue) &#8230; end</td></tr><tr><td>XCore::Daemon::VALUE</td><td>Any change to the named slot will fire the daemon.</td><td>@Operation(object,slot,newValue,oldValue) &#8230; end</td></tr><tr><td>XCore::Daemon::ADD</td><td>The slot must contain a set or sequence. When a new value is added to the set or sequence the daemon will fire. The action is supplied with the added value.</td><td>@Operation(object,slot,value) &#8230; end</td></tr><tr><td>XCore::Daemon::REMOVE</td><td>The slot must contain a set or sequence. When a value is removed from the set or sequence the daemon will fire. The action is supplied with the removed value.</td><td>@Operation(object,slot,value) &#8230; end</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id630129"></a>Elements</h3></div></div></div><p>All XOCL values are instances of the XCore class named Element.
      The operations defined by this class are available for all values in
      XMF-Mosaic. The following table shows the essential operations defined
      by this class. Note that XOCl is a dynamic language and new operations
      can be added to a class at any time. Adding operations to Element will
      cause these to be available for all values.</p><div class="table"><a name="id608608"></a><p class="title"><b>Table 3. </b></p><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>copy():Element</td><td>Returns a copy of the receiver. By default this returns the receiver. Sub-classes o Element may redefine this appropriately.</td></tr><tr><td>equals(other:Element):Boolean</td><td>Returns true when the receiver is equal to the argument. By default this is defined to be true when the identify (memory location) of elements with state are the same. Strings are compared character by character. Sets are equal when all elements are equal.</td></tr><tr><td>error(reason:String)</td><td>A convenient way of raising an error exception.</td></tr><tr><td>hashCode():Integer</td><td>Returns the code used to index into hash tables.</td></tr><tr><td>init(args:Seq(Element)):Element</td><td>All elements can be initialised with respect to arguments. See Object for more specific information.</td></tr><tr><td>isKindOf(c:Classifier):Boolean</td><td>Returns true when the receiver is an instance (dorect or otherwise) of the argument. Note that null is considered an instance of everything.</td></tr><tr><td>isReallyKindOf(classifier:Classifier):Boolean</td><td>True when isKindOf is true and the receiver is not null.</td></tr><tr><td>of():Classifier</td><td>Returns the direct classifier of the receiver.</td></tr><tr><td>send(message:String,args:Seq(Element)):Element
                </td><td>Sends the supplied message with the given arguments to the receiver. Returns the result.</td></tr><tr><td>toString():String</td><td>Produces a string representation of the receiver. The system uses toString to display XOCL values in all circumstances. It is usual to provide an appropriate definition of toString in all class definitions. This aids debugging systems.</td></tr><tr><td>yield()</td><td>Halt the current thread and reschedule it.</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id619560"></a>Integers</h3></div></div></div><p>This is the data type for integer values The default value is
      0.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id636618"></a>Operators</h4></div></div></div><p>All the usual operators on Integer types are provided.</p><div class="table"><a name="id656469"></a><p class="title"><b>Table 4. </b></p><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>Operator</td><td>Syntax</td><td>Result Type</td></tr><tr><td>equals</td><td>a = b</td><td>Boolean</td></tr><tr><td>not equals</td><td>a &lt;&gt; b</td><td>Boolean</td></tr><tr><td>less than</td><td>a &lt; b</td><td>Boolean</td></tr><tr><td>more than</td><td>a &gt; b</td><td>Boolean</td></tr><tr><td>less or equal</td><td>a &lt;= b</td><td>Boolean</td></tr><tr><td>more or equal</td><td>a &gt;= b</td><td>Boolean</td></tr><tr><td>plus</td><td>a + b</td><td>Integer or Float</td></tr><tr><td>minus</td><td>a - b</td><td>Integer or Float</td></tr><tr><td>multiplication</td><td>a * b</td><td>Integer or Float</td></tr><tr><td>divison</td><td>a / b</td><td>Integer or Float</td></tr><tr><td>operation</td><td>a.op()</td><td>Element</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id630946"></a>Operations</h4></div></div></div><p>A variety of integer operations are also provided.</p><div class="table"><a name="id633199"></a><p class="title"><b>Table 5. </b></p><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>abs():Integer</td><td>Returns the absolute value of an integer. </td></tr><tr><td>add(other:Element):Element</td><td>Adds an integer to another integer of a float. </td></tr><tr><td>asSeq():Seq(Integer)</td><td>Turns an integer into a 24 bit sequence of binary values. </td></tr><tr><td>bit(index:Element):Element</td><td>Returns the ith bit after converting an integer into a 24 bit sequence of binary values. </td></tr><tr><td>byte(index:Integer):Integer</td><td>Returns the byte of an indexed by index. Bytes are indexed from 1 (low) to 4 (high). </td></tr><tr><td>div(other:Integer):Integer</td><td>Integer division returns the number of times an integer can be divided by other a whole number of times. </td></tr><tr><td>floor():Integer</td><td>Rounds a float down to an integer. </td></tr><tr><td>greater(other:Integer):Element</td><td>Returns true if an integer is greater than other. </td></tr><tr><td>isAlphaChar():Boolean</td><td>Returns true if an integer is a valid alphanumeric value. </td></tr><tr><td>isLowerCaseChar():Boolean</td><td>Returns true if an integer is a valid lower case alphanumeric value. </td></tr><tr><td>isNewLineChar():Boolean</td><td>Returns true if an integer is the new line alphanumeric value.</td></tr><tr><td>isNumericChar():Boolean</td><td>Returns true if an integer is a valid numeric alphanumeric value. </td></tr><tr><td>isUpperCaseChar():Boolean</td><td>Returns true if an integer is a valid upper case alphanumeric value. </td></tr><tr><td>isWhiteSpaceChar():Boolean</td><td>Returns true if an integer is the white space alphanumeric value. </td></tr><tr><td>less(other:Element):Element</td><td>Returns true if the integer is lower than other. </td></tr><tr><td>lsh(n:Integer):Integer</td><td>Left shift bit operation.</td></tr><tr><td>max(other:Integer):Integer</td><td>Compares an integer with other and returns the maximum value. </td></tr><tr><td>min(other:Integer):Integer</td><td>Compares an integer with other and returns the minimum value. </td></tr><tr><td>mod(other:Integer):Integer</td><td>Returns the remainder when an integer is divided by other. </td></tr><tr><td>mul(other:Element):Element</td><td>Multiples an integer by other. </td></tr><tr><td>round():Integer</td><td>Rounds a float to the nearest whole integer. </td></tr><tr><td>rsh(n:Integer):Integer</td><td>Right shift bit operation.</td></tr><tr><td>slash(other:Element):Element</td><td>Divides an integer by other. </td></tr><tr><td>sqrt():Element</td><td>Returns the square root of an integer.</td></tr><tr><td>sub(other:Element):Element</td><td>Substracts other from an integer.</td></tr><tr><td>to(n:Integer):Seq(Integer)</td><td>Generates a sequence of integers from self to n.</td></tr><tr><td>toString():String</td><td>Converts an integer to a string.</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id627192"></a>Examples</h4></div></div></div><pre class="programlisting">13 * 42 = 546
12 &gt; 10 = false
12.max(11) = 12
12.min(11) = 11
12.mod(5) = 2
1.to(3) = Seq{1,2,3}</pre><p>The following example shows an operator
        definition for factorial. The operator is named fact, takes a single
        argument n and is defined in the global context Root which means that
        the name fact is available everywhere: </p><pre class="programlisting">context Root
  @Operation fact(n)
    if n = 0
    then 1
    else n * fact(n - 1)
    end
  end</pre><p>Another example of a global operation definition is gcd
        below that computes the greatest common divisor for a pair of positive
        integers. The example shows that operations can optionally have
        argument and return types: </p><pre class="programlisting">context Root
  @Operation gcd(m:Integer,n:Integer):Integer
    if m = n
    then n
    else
      if m &gt; n
      then gcd(m-n,n)
      else gcd(m,n-m)
      end
    end
  end</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id605296"></a>Floats</h3></div></div></div><p>The data type for real values. The default value is 0.0.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id638271"></a>Operators</h4></div></div></div><div class="table"><a name="id577883"></a><p class="title"><b>Table 6. </b></p><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>Operator</td><td>Syntax</td><td>Result Type</td></tr><tr><td>equals</td><td>a = b</td><td>Boolean</td></tr><tr><td>not equals</td><td>a &lt;&gt; b</td><td>Boolean</td></tr><tr><td>less than</td><td>a &lt; b</td><td>Boolean</td></tr><tr><td>more than</td><td>a &gt; b</td><td>Boolean</td></tr><tr><td>less or equal</td><td>a &lt;= b</td><td>Boolean</td></tr><tr><td>more or equal</td><td>a &gt;=</td><td>Boolean</td></tr><tr><td>plus</td><td>a + b</td><td>Integer or Float</td></tr><tr><td>minus</td><td>a - b</td><td>Integer or Float</td></tr><tr><td>multiplication</td><td>a * b</td><td>Integer or Float</td></tr><tr><td>division</td><td>a/b</td><td>Integer or Float</td></tr><tr><td>operation</td><td>a.op()</td><td>Element</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id671552"></a>Operations</h4></div></div></div><div class="table"><a name="id644906"></a><p class="title"><b>Table 7. </b></p><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>abs():Float</td><td>Returns the absolute value of a float. </td></tr><tr><td>add(other:Element):Element</td><td>Adds a float to other.</td></tr><tr><td>cos():Element</td><td>Returns the cosine of a float.</td></tr><tr><td>div(other:Element):Element</td><td>Divides a rounded float by the result of rounding other. </td></tr><tr><td>floor():Element</td><td>Rounds a float down to an integer. </td></tr><tr><td>greater(other:Element):Element</td><td>Returns true if a float is greater than other. </td></tr><tr><td>init(args:Element):Element</td><td>No Documentation Specified</td></tr><tr><td>less(other:Element):Element</td><td>Returns true if a float is less than other. </td></tr><tr><td>max(other:Integer):Integer</td><td>Compares a float with other and returns the maximum value. </td></tr><tr><td>min(other:Integer):Integer</td><td>Compares a float with other and returns the minimum value.</td></tr><tr><td>mod(other:Element):Element</td><td>Returns a float modulo other after rounding down to integers. </td></tr><tr><td>mul(other:Element):Element</td><td>Multiply a float by other.</td></tr><tr><td>round():Element</td><td>Returns the result of rounding a float down. </td></tr><tr><td>sin():Element</td><td>Returns the sin() of a float.</td></tr><tr><td>slash(other:Element):Element</td><td>Divided a float by other.</td></tr><tr><td>sqrt():Element</td><td>Returns the square root of a float.</td></tr><tr><td>sub(other:Element):Element</td><td>Subtracts an integer from a float.</td></tr><tr><td>toString():String</td><td>Converts and integer to a string.</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id580396"></a>Examples</h4></div></div></div><pre class="programlisting">1.1 &gt; 1.01 = true
3.5.round() = 4
3.2.floor() = 3
13.sqrt() = 3.6055512</pre><p>The following operation defines the
        operation abs(). If the float is a negative number it is subtracted
        from 0, otherwise the value of the float is returned.</p><pre class="programlisting">@Operation abs():Float
      if self &lt; 0
      then
        0 - self
      else
        self
      end
    end</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id668550"></a>Objects</h3></div></div></div><p>XOCL objects are XCore elements with slots. A slot is an
      association between a name (symbol) and a value. A slot has state and
      can be updated. All objects in XMF-Mosaic are instances of classes that
      inherit from the XCore class Object. The essential operations supported
      by Object are defined below:</p><div class="table"><a name="id617293"></a><p class="title"><b>Table 8. </b></p><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>addDaemon(d:Daemon)</td><td>All objects have a collection of daemons. A daemon is an operation that is invoked whenever a slot of the object is updated </td></tr><tr><td>daemons():Seq(Daemon)</td><td>Returns the currently defined daemons for the receiver. Daemons are fired when the object changes state and when the objects daemons are active. </td></tr><tr><td>daemonsActive():Boolean</td><td>Returns whether or not the daemons of this object will be fired when an update takes place.</td></tr><tr><td>get(name:String)</td><td>Returns the value of the named slot of the receiver. The name may be a string or a symbol. An exception is raised if the receiver has no slot with the given name.</td></tr><tr><td>getStructuralFeatureNames():Set(String)</td><td>Returns the slot names of the object. </td></tr><tr><td>hasDaemonWithId(id:Element):Boolean</td><td>Returns true when the receiver has a daemon with the supplied id.</td></tr><tr><td>hasSlot(name:Element):Boolean</td><td>Returns true when the receiver has a slot with the given name. The name may be a string or a symbol.</td></tr><tr><td>init(args:Element)</td><td>When an object is initialised, by default we look for a constructor that has the same arity as the supplied arguments. If we find one then it is invoked. This operation causes constructors to be invoked when they are defined for the class of the receiver. If this operation is redefined then you should use super(args) in the sub-class to invoke this operation.</td></tr><tr><td>removeDaemon(d:Daemon)</td><td>Removes the supplied daemon.</td></tr><tr><td>set(name:String,value:Element)</td><td>Sets the named slot to the supplied value in the receiver. Raises an exception if the receiver has no slot with the supplied name. The name may be a symbol or a string.</td></tr><tr><td>setDaemons(daemons:Seq(Daemon))</td><td>Updates the daemons of the receiver to be the supplied sequence.</td></tr><tr><td>setDaemonsActive(active:Boolean)</td><td>Sets whether or not the daemons of this receiver will be fired when an update takes place</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id591195"></a>Null</h3></div></div></div><p>The value null is an instance of the XCore class Null and is
      considered special in the sense that it can be viewed as the undefined
      value. It is an instance of all classes in XMF and is the default value
      of all slots whose type is not a basic type (such as String) or a set or
      sequence. There is only one null value and it is only equal to
      itself.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id591001"></a>Operations</h3></div></div></div><p>XOCL operations are used to implement both procedures and
      functions (queries). An operation has an optional name, some parameters,
      a return type and a body. Operations are objects with internal state;
      part of the internal state is the name, parameter information, type and
      body. Operations also have property lists that can be used to attach
      information to the operation for use by XOCL programs.</p><p>Operations can be created and stored in XMF data items. In
      particular, operations can be added to name spaces and then referenced
      via the name space (either where the name space is imported or directly
      by giving the path to the operation). We have seen many examples of
      adding operations to the name space called Root in earlier parts of this
      primer. The syntax:</p><pre class="programlisting">context Root
  @Operation add(x,y) x + y end</pre><p>can occur at the top-level of
      an XMF source file, compiled and loaded. It is equivalent to the
      following expression:</p><pre class="programlisting">Root.add(@Operation add(x,y) x + y end);</pre><p>Unlike
      the context expression, the call to add may occur anywhere in XMF
      code.</p><p>Operations are performed by sending them a message invoke with two
      arguments: the value of self (or target) to be used in the body of the
      operation and a sequence of argument values. The target of the
      invocation is important because it provides the value of self in the
      body of the operation and supplies the values of the slot-bound
      variables. The add operation can be invoked by:</p><pre class="programlisting">add.invoke(null,Seq{1,2})</pre><p>It
      produces the value 3. Note that in this case there is no reference to
      selfor slot-bound variables in the body and therefore the target of the
      invocation is null. A shorthand for invocation is provided:
      add(1,2)</p><p>However, note that no target can be supplied with the shorthand.
      In this case the target will default to the value of self that was in
      scope when the operation was created.</p><p>Locally bound variables that are scoped over an operation are
      available within the body of the operation event though the operation is
      returned from the lexical context. This is often referred to as closing
      the local variable into the operation (or closure). This feature is very
      useful when generating behaviour that differs only in terms of context.
      Suppose that transition machine states have an action that is
      implemented as an operation and that the action is to be performed when
      the state is entered:</p><pre class="programlisting">context StateMachines
  @Class State
    @Attribute name : String end
    @Attribute action : Operation end
    @Constructor(name,action) end
    @Operation enter()
      action()
    end
  end</pre><p>Compiled operations have the following slots:</p><div class="table"><a name="id696311"></a><p class="title"><b>Table 9. </b></p><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>arity</td><td>Integer</td><td>The number of arguments required by the operation.</td></tr><tr><td>codeBox</td><td>Element</td><td>The XVM instructions.</td></tr><tr><td>dynamics</td><td>Seq(element)</td><td>The global variables available via imports.</td></tr><tr><td>globals</td><td>Seq(Element)</td><td>The global variables available via imports.</td></tr><tr><td>isVarArgs</td><td>Boolean</td><td>Whether this operation can take a variable number of arguments.</td></tr><tr><td>properties</td><td>Seq(Element)</td><td>A sequence of name value pairs.</td></tr><tr><td>sig</td><td>Seq(Element)</td><td>A type signature for the operation.</td></tr><tr><td>supers</td><td>Seq(Operation)</td><td>A sequence of operations headed by the owner of the slot. Used when invoking super.</td></tr><tr><td>target</td><td>Element</td><td>Value used as self within the operation.</td></tr><tr><td>traced</td><td>Operation</td><td>An operation used as a proxy when the operation is traced. (null is not traced).</td></tr></tbody></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id706737"></a>Operations</h4></div></div></div><p>Compiled operation defines the following operations:</p><div class="table"><a name="id563265"></a><p class="title"><b>Table 10. </b></p><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>addDaemon(daemon:Element)</td><td>Operations have daemons that monitor their slots.</td></tr><tr><td>addNameChangedDaemon(d:Element,actionSource:Element) </td><td>Use this operation to add a daemon that monitors the name of a compiled operation for changes. The args for the daemon are the new name and the old name.</td></tr><tr><td>arity():Integer</td><td>The number of arguments expected by the operation. Use this rather than reference the slot.</td></tr><tr><td>daemons():Seq(Operation)</td><td>Returns the daemons currently monitoring the operation.</td></tr><tr><td>disassemble():String</td><td>Displays the XVM instructions to stdout.</td></tr><tr><td>disassemble(out:Element)</td><td>Displays the XVM instructions to out.</td></tr><tr><td>doc():Element</td><td>Any documentation defined for the receiver.</td></tr><tr><td>get(name:String):Element</td><td>Reference a named slot of the receiver.</td></tr><tr><td>getStructuralFeatureNames():Set(String)</td><td>Get the slots defined for the receiver.</td></tr><tr><td>hasProperty(property:Element):Boolean</td><td>Returns true when the receiver has the supplied property.</td></tr><tr><td>hasSlot(name:String):Boolean</td><td>Returns true when the receiver has the supplied name.</td></tr><tr><td>importNameSpace(n:NameSpace)</td><td>Imports the supplied name space and its contents to the receiver. If the name space is already imported then no change is made. Otherwise the name space is added as the most specific imported name space.</td></tr><tr><td>importNameSpaces(N:Seq(NameSpace))</td><td>Imports the sequence of name spaces in the order that they are supplied.</td></tr><tr><td>imports(n:NameSpace):Boolean</td><td>Returns true when the receiver imports the supplied name space.</td></tr><tr><td>imports():Seq(NameSpace)</td><td>Returns the sequence of imported name spaces.</td></tr><tr><td>isVarArgs():Boolean</td><td>returns true when the receiver can be supplied with a variable number of arguments. Use this in preference to referencing the slot.</td></tr><tr><td>name():Symbol</td><td>Returns the name of the receiver. Use this in preference to referencing the slot.</td></tr><tr><td>owner():Element</td><td>Returns the owner of the receiver. Use this in preference to referencing the slot.</td></tr><tr><td>paramNames():Seq(String)</td><td>Returns the sequence of parameter names.</td></tr><tr><td>paramTypes():Seq(Classifier)</td><td>Returns the sequence of parameter types.</td></tr><tr><td>properties():Element</td><td>Returns the receivers property list.</td></tr><tr><td>property(property:Element):Element</td><td>Returns the value of the supplied property.</td></tr><tr><td>removeDaemon(daemon:Element)</td><td>Removes the supplied daemon.</td></tr><tr><td>set(name:String,value:Element)</td><td>Sets the supplied slot.</td></tr><tr><td>setArity(arity:Element) </td><td>Changes the arity (don&#8217;t use).</td></tr><tr><td>setDaemons(daemons:Element)</td><td>Sets the daemons.</td></tr><tr><td>setDoc(doc:Element)</td><td>Sets the documentation.</td></tr><tr><td>setName(name:Element)</td><td>Sets the name.</td></tr><tr><td>setOwner(owner:Element)</td><td>Sets the owner.</td></tr><tr><td>setProperties(properties:Element)</td><td>Sets the properties.</td></tr><tr><td>setProperty(property:Element,value:Element)</td><td>Sets the property.</td></tr><tr><td>setSig(sig:Element)</td><td>Sets the type signature.</td></tr><tr><td>setSource(source:String)</td><td>Sets the source code string.</td></tr><tr><td>setSupers(supers:Element)</td><td>Sets the supers list.</td></tr><tr><td>setTarget(target:Element)</td><td>Sets the target.</td></tr><tr><td>sig():Seq(Element)</td><td>Returns the type signature.</td></tr><tr><td>source():String</td><td>Returns the source code string.</td></tr><tr><td>supers():Seq(Operation)</td><td>Returns the supers list.</td></tr><tr><td>target():Element</td><td>Returns the target.</td></tr><tr><td>trace():Operation</td><td>Returns the trace operation.</td></tr><tr><td>traced():Boolean</td><td>True when the receiver is traced.</td></tr><tr><td>type():Classifier</td><td>Returns the return type.</td></tr><tr><td>untrace()</td><td>Stops printing trace information when the receiver is invoked.</td></tr><tr><td>update(newOp:Element)</td><td>Replaces the receiver with the argument. The update is performed in place so that all references to the receiver are also updated.</td></tr></tbody></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id667331"></a>Strings</h3></div></div></div><p>A string is a sequence of characters. Literal strings are written
      in enclosing double string quotes, such as &#8220;fred&#8221; and &#8220;fido&#8221;.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id587854"></a>Operators</h4></div></div></div><p>Strings can be compared using equals (=) and can be
        concatenated.</p><div class="table"><a name="id562874"></a><p class="title"><b>Table 11. </b></p><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>Operator</td><td>Syntax</td><td>Result Type</td></tr><tr><td>equals</td><td>a = b</td><td>Boolean</td></tr><tr><td>not equals</td><td>a &lt;&gt; b</td><td>Boolean</td></tr><tr><td>concatenate</td><td>a + b</td><td>String</td></tr><tr><td>operation</td><td>a.op()</td><td>Element</td></tr></tbody></table></div><p>Strings can also be compared using &lt;, &lt;=, &gt; and
        &gt;= in which case the usual lexicographic ordering applies.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id617355"></a>Operations</h4></div></div></div><p>A large number of string operations are provided for
        manipulating strings. These are given below.</p><div class="table"><a name="id712884"></a><p class="title"><b>Table 12. </b></p><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>asBool():Boolean</td><td>Converts a string into a Boolean provided it has the string value true or false. String can be lower or upper case. An exception is raised if the string is invalid.</td></tr><tr><td>asFloat():Float</td><td>Converts a string into a Float. It splits the string on its decimal point, converts the two strings into integers and passes them to the Float constructor. An exception is raised if the result is not a Float.</td></tr><tr><td>asHTML():String</td><td>Transforms a string literal to HTML replacing any illegal HTML characters so that the string is faithfully printed.</td></tr><tr><td>asInt():Integer</td><td>Converts a string into an Integer. Raises an exception if it cannot be converted.</td></tr><tr><td>asSeq():Seq(Integer)</td><td>Converts a string into a sequence of character codes.</td></tr><tr><td>asSet():Set(Integer)</td><td>Converts a string into a set of character codes</td></tr><tr><td>asSymbol():Symbol</td><td>Converts a string into a Symbol. In general, symbols can be processed more efficiently than strings, e.g. as indexes in table lookups.</td></tr><tr><td>at(i:Integer):Integer</td><td>Returns the ith character in a string starting from position 0.</td></tr><tr><td>default():Element</td><td>Returns the default value for a string: the empty string</td></tr><tr><td>deleteFile():Boolean</td><td>Deletes the file given by a string path. Raises an exception if the file does not exist or cannot be deleted.</td></tr><tr><td>drop(n:Integer):Element</td><td>Removes the first i elements from a string.</td></tr><tr><td>edit():Element</td><td>Launches an editor for a string.</td></tr><tr><td>escapeCharsToNewLines():Element</td><td>Substitutes escape characters in a string for new lines.</td></tr><tr><td>exec(args:Seq(String)):Element</td><td>Currently not supported.</td></tr><tr><td>fileExists():Boolean</td><td>Returns true if the file given by a string path exists, otherwise false.</td></tr><tr><td>fileSize():Integer</td><td>Returns the size of a file given by a string path.</td></tr><tr><td>greater(other:String):Boolean</td><td>Returns true if a string is greater than the supplied string. The strings are compared alphabetically.</td></tr><tr><td>hasPrefix(prefix:String):Boolean</td><td>Returns true if a string is prefixed by the string, prefix.</td></tr><tr><td>hasSuffix(suffix:String):Boolean</td><td>Returns true if a string has a suffix, suffix.</td></tr><tr><td>indexOf(char:String):Integer</td><td>Returns the index of a character, char in a string.</td></tr><tr><td>isOlder(file:String):Boolean</td><td>Compares the last modified date of the file referenced by a string path with file. Returns true if file is older.</td></tr><tr><td>less(other:String):Boolean</td><td>Returns true if a string is less than the supplied string. The strings are compared alphabetically. </td></tr><tr><td>loadBin(verbose:Boolean):Element</td><td>Load the binary for the file referenced by a string path. Displays loading information if verbose is true. Raises an exception if it does not exist.</td></tr><tr><td>lookup():Element</td><td>Returns the value of the dynamic variable with the name defined by self or raises an error otherwise.</td></tr><tr><td>lowerCaseInitialLetter():String</td><td>Makes the first letter of a string lower case.</td></tr><tr><td>mkDir():Boolean</td><td>Creates a directory. Returns true when the directory already exists or is successfully created. Returns false when the directory cannot be created.</td></tr><tr><td>newLinesToEscapeChars():Element</td><td>Substitutes new lines in a string for escape characters.</td></tr><tr><td>padFrom(width:Integer,char:Integer):String</td><td>Pads ups to a string with additional character codes up to width</td></tr><tr><td>padTo(width:Integer,char:Integer):String</td><td>Pads after a string with additional character codes up to width.</td></tr><tr><td>parentDir():String</td><td>Returns the parent directory of the file referenced by a string path. Returns an exception if it cannot be found.</td></tr><tr><td>readFile():String</td><td>Reads the file referenced by a string path, provided that it exists.</td></tr><tr><td>renameFile(newName:String):Boolean</td><td>Renames a file referenced by a string path. A rename is only performed if the file exists and there doesnt exist a file with the new name.</td></tr><tr><td>repeat(n:Integer):Element</td><td>Duplicates a string the given number of times.</td></tr><tr><td>reverse():String</td><td>Reverses the characters in a string. </td></tr><tr><td>size():Integer</td><td>Returns the size of a string.</td></tr><tr><td>splitBy(chars:String,start:Integer,last:Integer):Seq(String)</td><td>Splits a string into a sequence of strings around some characters. The variables start and last can be used to filter the returned string by returning the characters from start to last. Setting start and last to 0 will return the whole string.</td></tr><tr><td>stripNonAlphaChars():String</td><td>Strips all non-alphanumeric characters from a string.</td></tr><tr><td>stripWhiteSpace():String</td><td>Strips any whitespaces from a string.</td></tr><tr><td>subString(firstChar:String,pastLastChar:String):String</td><td>Uses indices to chop up a string. The first index is the starting character and the second index is 1+ the final character.</td></tr><tr><td>subst(new:String,old:String,all:Boolean):Element</td><td>Substitutes the string old in a string with new. If all is set to false, just replaces the first occurence. If true replaces them all.</td></tr><tr><td>toLower():String</td><td>Converts all characters in a string to lower case.</td></tr><tr><td>toString():String</td><td>Prints a string.</td></tr><tr><td>toUpper():String</td><td>Converts all characters in a string to upper case.</td></tr><tr><td>truncate(width:Integer):String</td><td>Truncates a string by width characters.</td></tr><tr><td>upperCaseInitialLetter():String</td><td>Makes the first letter of a string upper case.</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id749313"></a>Examples</h4></div></div></div><pre class="programlisting">"to" + "day" = "today"
"tomorrow".size() = 8
"UPPER".toLower() = "upper"
"lower".toUpper() = "LOWER"
"Ceteva".subString(0,4) = "Xact"
"lower" &lt;&gt; "LOWER" = true
"123.456".splitBy(".",0,0) = Seq{"123","456"}</pre><p>Characters are
        represented as integer ASCII codes. The following operation checks
        whether a string starts with an upper case character:</p><pre class="programlisting">context Root
@Operation startsUpperCase(s:String):Boolean
  if s-&gt;size &gt; 0
  then
    let c = s-&gt;at(0)
    in "A"-&gt;at(0) &lt;= c and c &lt;= "Z"-&gt;at(0)
    end
  else false
  end
end</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id568404"></a>Sequences</h3></div></div></div><p>A sequence is a list of values that may have duplicates. A
      sequence literal is denoted by enumerating the elements in a Seq{}. For
      example, a sequence of numbers: Seq{1,2,3}. Sequences can be nested, for
      example: Seq{Seq{&#8220;a&#8221;,&#8221;b&#8221;},1}.</p><p>The default value of a sequence is the empty sequence, Seq{}. A
      Seq(Element) is an instance of the Sequence type. It contains the
      elements in the sequence.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id660670"></a>Operators</h4></div></div></div><p>Two sequences can be tested for equality and inequality. Two
        sequences are equal provides that they contain the same elements in
        the same order. Sequences can be concatenated.</p><div class="table"><a name="id587465"></a><p class="title"><b>Table 13. </b></p><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>Operator</td><td>Syntax</td><td>Result Type</td></tr><tr><td>equals</td><td>a = b</td><td>Boolean</td></tr><tr><td>not equals</td><td>a &lt;&gt; b</td><td>Boolean</td></tr><tr><td>concatenation</td><td>a + b</td><td>Sequence(Element)</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id627285"></a>Operations</h4></div></div></div><p>XOCL provides a large number of sequence operations, including
        all those support by standard OCL.</p><div class="table"><a name="id652267"></a><p class="title"><b>Table 14. </b></p><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>append(s:Seq(Element)):Seq(Element)</td><td>Append two sequences.</td></tr><tr><td>asProperSeq():Seq(Element)</td><td>No Documentation Specified</td></tr><tr><td>asSeq():Seq(Element)</td><td>Turns a sequence into a sequence.</td></tr><tr><td>asSet():Set(Element)</td><td>Turn a sequence into a set.</td></tr><tr><td>asString():String</td><td>Turns a sequence of integers into a string.</td></tr><tr><td>asVector():Vector</td><td>Turns a sequence into a vector.</td></tr><tr><td>at(n:Integer):Element</td><td>Returns the nth element of a sequence starting from 0.</td></tr><tr><td>bind(key:Element,value:Element):Seq(Element)</td><td>Binds a key with a value and adds it to the head of the sequence.</td></tr><tr><td>binds(key:Element):Boolean</td><td>Returns true of a sequence contains a binding that matches the key/</td></tr><tr><td>butLast():Seq(Element)</td><td>Returns all elements but the last element.</td></tr><tr><td>contains(element:Element):Boolean</td><td>Returns true if the sequence contains the element.</td></tr><tr><td>default():Seq(Element)</td><td>Returns the default sequence: an empty sequence.</td></tr><tr><td>dot(name:String):Seq(Element)</td><td>Returns the result of iterating over a sequence and performing dot on each element.</td></tr><tr><td>drop(n:Integer):Seq(Element)</td><td>Drops the first n elements from a sequence.</td></tr><tr><td>equals(other:Element):Boolean</td><td>Returns true if a sequence equals another sequence. To be equal they must both be sequences and their elements should be equal and in the same order.</td></tr><tr><td>excluding(element:Element):Element</td><td>Returns all elements in the sequence excluding element.</td></tr><tr><td>exists(pred:Element):Boolean</td><td>Returns true when one element of the sequence satisfies the predicate otherwise it returns false.</td></tr><tr><td>flatten():Seq(Element)</td><td>Turns a sequence of sequences of X into a sequence of X. </td></tr><tr><td>forAll(pred:Element):Boolean</td><td>Returns true if all elements of the sequence satisfy the predicate otherwise returns false.</td></tr><tr><td>hasPrefix(prefix:Seq(Element)):Boolean</td><td>Returns true if a sequence is prefixed by the sequence prefix.</td></tr><tr><td>hasSuffix(suffix:Seq(Element)):Boolean</td><td>Returns true if a sequence is suffixed by the sequence suffix</td></tr><tr><td>head():Element</td><td>Returns the head of a sequence.</td></tr><tr><td>includes(element:Element):Boolean</td><td>Returns true if a sequence contains element. </td></tr><tr><td>includesAll(c:Collection(Element)):Boolean</td><td>Returns true if a sequence includes all the elements in the collection c.</td></tr><tr><td>including(e:Element):Seq(Element)</td><td>Returns the result of including the element e in a sequence. The element is added to the head of the sequence.</td></tr><tr><td>indexOf(element:Element):Integer</td><td>Returns the first index of the element in a sequence. If it is not found, returns -1.</td></tr><tr><td>insertAt(e:Element,i:Integer):Seq(Element)</td><td>Inserts an element e at position i in a sequence.</td></tr><tr><td>inspectDialog(level:Element):Element</td><td>No Documentation Specified</td></tr><tr><td>isEmpty():Boolean</td><td>Returns true if a sequence is empty.</td></tr><tr><td>isKindOf(type:Classifier):Boolean</td><td>Returns true if all elements in a sequence are instances of type.</td></tr><tr><td>isProperSequence():Boolean</td><td>Returns true if the last tail is a valid sequence.</td></tr><tr><td>iter(iterator:Element,value:Element):Seq(Element)</td><td>Iterates through a sequence, returning a sequence.</td></tr><tr><td>last():Element</td><td>Returns the last element of a non-empty sequence.</td></tr><tr><td>linkAt(element:Element,index:Integer):Seq(Element)</td><td>Returns the last element of a non-empty sequence.</td></tr><tr><td>lookup(key:Element):Element</td><td>Looks up a pair in a sequence using the key. Returns an error if the key cannot be found.</td></tr><tr><td>max():Integer</td><td>Returns the maximum valued element in the sequence.</td></tr><tr><td>mul(s:Seq(Element)):Seq(Element)</td><td>Generates a sequence containing all combinations of elements in the two sequences.</td></tr><tr><td>prefixes():Seq(Element)</td><td>Returns all possible prefixes of a sequence including the empty sequence.</td></tr><tr><td>prepend(e:Element):Seq(Element)</td><td>Prepend adds an element to the head of a sequence and returns a new sequence.</td></tr><tr><td>qsort(pred:Operation):Seq(Element)</td><td>Quicksorts the elements in the sequence. Is supplied with an operation of the form @Operation(x,y) predicate en-d where x and y will be elements in the sequence. An example predicate might be x &lt; y. </td></tr><tr><td>ref(nameSpaces:Element):Element</td><td>ooks up a namespace path represented as a sequence of strings to the element found at the path. The operation takes a sequence of namespaces as an argument; the namespace arguments are used as the basis for the lookup.</td></tr><tr><td>reverse():Seq(Element)</td><td>Reverses a sequence.</td></tr><tr><td>sel():Element</td><td>Returns one element from a sequence.</td></tr><tr><td>select(predicate:Element):Seq(Element)</td><td>Applies a filter to a sequence of elements.</td></tr><tr><td>separateWith(sep:String):String</td><td>Constructs a string by concatenating the elements of a sequence together, separated by sep.</td></tr><tr><td>set(key:Element,value:Element):Seq(Element)</td><td>Sets the value of a binding in a sequence indexed by key. Creates a binding if one does not exist.</td></tr><tr><td>size():Integer</td><td>Returns the size of a sequence. </td></tr><tr><td>sort(pred:Element):Seq(Element)</td><td>Sorts a sequence using a comparison predicate of the form @Operation(x,y) predicate end. The predicate must be a comparison expression, e.g. x &lt; y.</td></tr><tr><td>sortByString():Seq(Element)</td><td>Sorts by string value.</td></tr><tr><td>sortNamedElements():Seq(NamedElement)</td><td>Sorts a sequence of named elements. This operation is implemented in the kernel as is therefore very fast.</td></tr><tr><td>sortNamedElements_CaseIndependent():Seq(Element)</td><td>Sorts named elements by names ignoring case.</td></tr><tr><td>sortNames():Seq(String)</td><td>Sorts a sequence of names.</td></tr><tr><td>subSequence(starting:Element,terminating:Element):Element</td><td>Produces a subsequence given two indices. The first index is inclusive and is the starting index. The second index is exclusive and is the terminating index.</td></tr><tr><td>subst(new:Element,old:Element,all:Boolean):Seq(Element)</td><td>Substitutes old for new in a sequence. If all is true, it will replace all elements, otherwise it will replace the first element.</td></tr><tr><td>tail():Seq(Element)</td><td>Returns the tail of a sequence.</td></tr><tr><td>take(n:Integer):Element</td><td>Takes n elements from the tail of a sequence.</td></tr><tr><td>toString():String</td><td>Produces a printed representation of a sequence.</td></tr><tr><td>zip(s:Seq(Element)):Seq(Element)</td><td>Produces a sequences of pairs by matching the first element of a sequence with the first element of s, and so on...</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id614921"></a>Examples</h4></div></div></div><pre class="programlisting">Seq{"red"}+Seq{"green"} = Seq{"red","green"}
Seq{"red"}-&gt;at(0) = "red"
Seq{"red","green"}-&gt;last() = "green"
Seq{"red"}-&gt;insertAt(0,"green") = Seq{"red","green"}
Seq{"red","green"}-&gt;indexOf("green") = 1
Seq{"red","green","amber"}-&gt;subSequence(1,2) = Seq{"green"}
Seq{"red","green","amber"}-&gt;tail() = Seq{"green","amber"}</pre><p>The
        operation butLast returns all elements in a sequence but the last
        element. It could have been defined as follows, note the use of
        Seq{head | tail} to construct a sequence with the given head and
        tail:</p><pre class="programlisting">context Seq(Element)
  @Operation butLast():Seq(Element)
    if self-&gt;size = 0
    then self.error("Seq(Element)::butLast: empty sequence.")
    else if self-&gt;size = 1
      then Seq{}
      else Seq{self-&gt;head | self-&gt;tail-&gt;butLast}
      end
    end
  end</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id674338"></a>Sets</h3></div></div></div><p>A set is a list of values that may not have duplicates. A set
      literal is denoted by enumerating the elements in a Set{}. For example,
      a set of numbers: Set{1,2,3}. Sets can be nested, for example:
      Set{Set{&#8220;a&#8221;,&#8221;b&#8221;},1}. The default value of a set is the empty set, Set{}.
      A Set(Element) is an instance of the Set type. It contains the elements
      in the set.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id644412"></a>Operators</h4></div></div></div><p>Two sets can be tested for equality and inequality. Two sets are
        equal provided they contain the same elements irrespective of
        order.</p><div class="table"><a name="id564240"></a><p class="title"><b>Table 15. </b></p><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>Operator</td><td>Syntax</td><td>Result Type</td></tr><tr><td>equals</td><td>a = b</td><td>Boolean</td></tr><tr><td>not equals</td><td>a &lt;&gt; b</td><td>Boolean</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id566867"></a>Operations</h4></div></div></div><div class="table"><a name="id637125"></a><p class="title"><b>Table 16. </b></p><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>asSeq():Seq(Element)</td><td>Turns a set into a sequence.</td></tr><tr><td>asSet():Set(Element)</td><td>Turns a set into a set.</td></tr><tr><td>collect(filter:Element):Set(Element)</td><td>Returns the set of elements that result from evaluating filter over a set.</td></tr><tr><td>contains(element:Element):Boolean</td><td>Returns true if a set contains an element.</td></tr><tr><td>default():Set(Element)</td><td>Returns the default value of a set: the empty set.</td></tr><tr><td>dot(name:String):Set(Element)</td><td>Returns the result of iterating over a set and applying dot to the slot named name.</td></tr><tr><td>edit():Element</td><td>Launches a browser for a set.</td></tr><tr><td>excluding(element:Element):Set(Element)</td><td>The set excluding the element.</td></tr><tr><td>exists(pred:Element):Element</td><td>Returns true if an element satisfying the predicate exists in a set.</td></tr><tr><td>flatten():Set(Element)</td><td>Turns a set of sets into a set.</td></tr><tr><td>includes(element:Element):Boolean</td><td>Returns true if a set includes element.</td></tr><tr><td>includesAll(c:Collection(Element)):Boolean</td><td>Returns true if a set includes all elements from another collection.</td></tr><tr><td>including(element:Element):Set(Element)</td><td>The result of the set including element.</td></tr><tr><td>intersection(set:Set(Element)):Set(Element)</td><td>Returns the intersection of two sets.</td></tr><tr><td>isEmpty():Boolean</td><td>Returns true if the set is empty.</td></tr><tr><td>isKindOf(type:Classifier):Boolean</td><td>Returns true if all elements in a set are of the type.</td></tr><tr><td>iter(iterator:Element,value:Element):Element</td><td>Iterates over the elements in the set</td></tr><tr><td>max():Integer</td><td>Find the element with the maximum value in the set.</td></tr><tr><td>power():Set(Element)</td><td>Returns the powerset of elements in a set, i.e. all possible subsets of a set including the empty set.</td></tr><tr><td>reject(pred:Element):Set(Element)</td><td>Rejects any elements in the set that satisfy the predicate.</td></tr><tr><td>sel():Element</td><td>Selects a single element from a set.</td></tr><tr><td>select(predicate:Element):Set(Element)</td><td>Selects any elements in the set that satisfy the predicate.</td></tr><tr><td>size():Integer</td><td>Returns the size of the set.</td></tr><tr><td>toString():String</td><td>Prints the set as a string/</td></tr><tr><td>union(set:Set(Element)):Set(Element)</td><td>Returns the union of the two sets.</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id572699"></a>Examples</h4></div></div></div><pre class="programlisting">Set{1,2,3}-&gt;includes(1) = true
Set{1,2,3}-&gt;includesAll(1,2) = true
Set{1,2,3}-&gt;including(4) = Set{1,2,3,4}
Set{1,2,3}-&gt;excludes(1) = false
Set{1,2,3}-&gt;excludesAll(Set{4,5}) = true
Set{1,2,3}-&gt;excluding(1) = Set{2,3}
Set{1,2}-&gt;union(Set{2,3}) = Set{1,2,3}
Set{1,2,3} - Set{1,2,3} = Set{}
Set{1,2}-&gt;intersection(Set{2,3}) = Set{2}
Set{}-&gt;isEmpty() = true
Set{1,2,3}-&gt;size() = 3
Set{1}-&gt;sel() = 1
Set{Set{1},Set{2}}-&gt;flatten() = Set{1,2}</pre><p>Suppose that the
        set operation includes was not provided as part of XOCL. It could be
        defined by:</p><pre class="programlisting">context Set(Element)
  @Operation includes(e:Element):Boolean
    if self-&gt;isEmpty
    then false
    else
     let x = self-&gt;sel
     in if x = e
       then true
       else self-&gt;excluding(x)-&gt;includes(e)
       end
     end
   end
end</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id650623"></a>Symbols</h3></div></div></div><p>Symbol is a sub-class of String. Whereas there may be two
      different strings with the same sequence of characters, there can only
      be one symbol with the same sequence of characters. This is useful when
      using names as the basis for lookup (in tables). For example XMF ensures
      that classes, packages, operations, slots are named using symbols so
      that the lookup of these features by name is as efficient as possible.
      If strings were used the lookup would necessarily involve a
      character-by-character comparison. Using symbols the lookup can use the
      symbols identity as the comparison operator. You can reference a symbol
      by constructing an instance: Symbol(name).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id622829"></a>Operations</h4></div></div></div><div class="table"><a name="id705187"></a><p class="title"><b>Table 17. </b></p><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td>Operator</td><td>Syntax</td><td>ResultType</td></tr><tr><td>equals</td><td>a = b</td><td>Boolean</td></tr><tr><td>not equals</td><td>a &lt;&gt; b</td><td>Boolean</td></tr><tr><td>greater</td><td>a &gt; b</td><td>Boolean</td></tr><tr><td>less than</td><td>a &lt; b</td><td>Boolean</td></tr></tbody></table></div><p>Symbols can be compared for equality, non-equality, greater
        than and less than, in which case the usual lexicographic ordering
        applies.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id645232"></a>Tables</h3></div></div></div><p>A table associates keys with values. Any element can be used as a
      key. A table has an initial size and can support any number of values.
      Use 'hasKey/1' to determine whether a table contains a key. Use 'get/1'
      to access a table via a key and 'put/2' to update a table given a key
      and a value. Use 'keys/0' to access the set of keys for a table.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id713905"></a>Operations</h4></div></div></div><div class="table"><a name="id693883"></a><p class="title"><b>Table 18. </b></p><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>get(key:Element):Element</td><td>Return the value of the supplied key in the table. If the key does not exist then an exception is raised. Use 'hasKey/1' to check if the key exists.</td></tr><tr><td>hasKey(key:Element):Boolean</td><td>Tests whether the table has a key or not.</td></tr><tr><td>keys():Seq(Element)</td><td>Returns all the keys in the table.</td></tr><tr><td>pprint():String</td><td>This operation prints out all the entries in a table.</td></tr><tr><td>put(key:Element,value:Element):Element</td><td>Add an association between the supplied key and value. Any existing association for the key is removed.</td></tr><tr><td>ref(index:Integer):Element</td><td>No Documentation Specified</td></tr><tr><td>remove(key:Element):Element</td><td>Remove the supplied key from the table. This succeeds whether the key exists in the tabel or not. Any daemons defined for the table are performed. The table is returned.</td></tr><tr><td>set(index:Integer,value:Element):Element</td><td>No Documentation Specified</td></tr><tr><td>size():Integer</td><td>Returns the size of a table.</td></tr><tr><td>toString():String</td><td>Returns a string representation of a table.</td></tr><tr><td>values():Set(Element)</td><td>Returns all elements in the tables as a set.</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id586650"></a>Examples</h4></div></div></div><p>The following example adds and retrieves elements from a
        table:</p><pre class="programlisting">context Root
  @Class Fill
    @Attribute table : Table(1000) end
    @Operation add(key,element)
      self.table.put(key,element)
    end
    @Operation retrieve(key)
      self.table.get(key)
     end
  end</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id589615"></a>Threads</h3></div></div></div><p>XOCL provides threads for concurrent processing. A new thread of
      control is created using the special form:</p><pre class="programlisting">@Fork(n) 
  body
end</pre><p>where n is a name used to identify the thread and body is
      an XOCL expression that is run when the thread starts. At any time the
      XVM is executing a single thread of control. The thread continues on the
      XVM until either it performs a read operation that blocks on input or
      when it explicitly calls yield. All XOCL values implement the yield
      operation. In both cases the thread is said to yield control. When a
      thread yields control, the XOS schedules another thread that is waiting.
      The scheduling algorithm aims to ensure that all waiting threads get
      scheduled providing that they yield.</p><p>Note that XMF is not intended to be a heavy-weight concurrent
      programming environment. Threads are provided for light-weight use,
      primarily for handling multiple connections from processes that
      communicate with XMF via input and output channels. There is nothing to
      stop threads being used to implement a variety of concurrent process
      architectures, however there are no facilities in XMF for controlling
      concurrent access to resource (such as locks, monitors etc).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id600413"></a>Vectors</h3></div></div></div><p>Vectors provide an efficient way of maintaining and accessing an
      array of values. Vectors are created using the constructor
      Vector(&lt;vector length&gt;), where size is the length of the vector. A
      vector is indexed starting at position 0.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id662465"></a>Operations</h4></div></div></div><p>A vector is a fixed length array of elements. They are created
        using the constructor Vector(). Vectors provide very efficient insert
        (put/2) and lookup operations (ref/1).</p><div class="table"><a name="id582205"></a><p class="title"><b>Table 19. </b></p><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>asSeq():Seq(Element)</td><td>Converts a vector into a sequence. </td></tr><tr><td>asString():String</td><td>Converts a vector to a string.</td></tr><tr><td>copyInto(vector:Element):Element</td><td>Copies the elements of vector into self starting at position 0.</td></tr><tr><td>put(index:Element,value:Element):Element</td><td>Put the element value into a vector at position index.</td></tr><tr><td>ref(index:Element):Element</td><td>Returns the value at position index in a vector.</td></tr><tr><td>size():Integer</td><td>Returns the size of a vector.</td></tr><tr><td>toString():String</td><td>Returns a string representation of a vector.</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id651453"></a>Examples</h4></div></div></div><p>The following operation creates a vector and populates it with
        element.</p><pre class="programlisting">context Vector
  @Operation fill(element:Element)
     @For e in 0.to(self.size()) do
       self.put(e,element)
     end
  end</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id569905"></a>Debugging</h3></div></div></div><p>XOCL operation invocation can be traced to check whether the
      operator is being called correctly. To trace an operation send it a
      trace message with no arguments. To stop the trace, send it an untrace
      message with no arguments. A traced operation will print out its
      arguments when it is called and its return value when it returns. All
      the operations defined in a name space N can be traced and untraced by
      N.traceAll() and N.untraceAll().</p></div></div><p></p><p><img src="copyright.gif"></p></body></html>
